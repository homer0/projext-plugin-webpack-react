<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/plugin.js | projext-plugin-webpack-react</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Allows you to bundle a React project with projext using the webpack build engine."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="projext-plugin-webpack-react"><meta property="twitter:description" content="Allows you to bundle a React project with projext using the webpack build engine."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/projext-plugin-webpack-react"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/plugin.js~ProjextReactPlugin.html">ProjextReactPlugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/class/src/app/index.js~Projext.html">Projext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/typedef/index.html#static-typedef-Target">Target</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://homer0.github.io/projext/class/src/services/targets/targets.js~Targets.html">Targets</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/plugin.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * This service is in charge of modifying a target Babel and entry settings in order to build
 * React code. It also manages the settings related to the React Hot Loader.
 */
class ProjextReactPlugin {
  /**
   * Class constructor.
   * @ignore
   */
  constructor() {
    /**
     * The name of the reducer event the service will listen in order to intercept the rules for
     * JS files and update them.
     * @type {string}
     */
    this.jsRulesEvent = &apos;webpack-js-rules-configuration&apos;;
    /**
     * The name of the reducer event the service will listen in order to intercept the rules for
     * SCSS files and update them.
     * @type {string}
     */
    this.scssRulesEvent = &apos;webpack-scss-rules-configuration&apos;;
    /**
     * The name of the reducer event the service will listen in order to intercept the rules for
     * css files and update them.
     * @type {string}
     */
    this.cssRulesEvent = &apos;webpack-css-rules-configuration&apos;;
    /**
     * The name of the reducer event the service will listen in order to intercept the rules for
     * fonts files, and if the target implements SSR, update them.
     * @type {string}
     */
    this.fontsRulesEvent = &apos;webpack-fonts-rules-configuration&apos;;
    /**
     * The name of the reducer event the service will listen in order to intercept the rules for
     * images files, and if the target implements SSR, update them.
     * @type {string}
     */
    this.imagesRulesEvent = &apos;webpack-images-rules-configuration&apos;;
    /**
     * The name of the reducer event the service will listen for and use to update a target entry
     * settings if the target `hot` property is `true`.
     * @type {string}
     */
    this.targetEventName = &apos;webpack-browser-development-configuration&apos;;
    /**
     * The required value a target `framework` setting needs to have in order for the service to
     * take action.
     * @type {string}
     */
    this.frameworkProperty = &apos;react&apos;;
    /**
     * The default values for the options a target can use to customize how the plugin works.
     * @type {Object}
     * @property {Array} ssr A list of other targets being used for SSR (Server Side Rendering) and
     *                       which paths should be included by processing the JSX.
     */
    this.frameworkOptions = {
      ssr: [],
    };
    /**
     * The name of the Babel preset the service will insert into the targets configurations.
     * @type {string}
     */
    this.presetName = &apos;react&apos;;
    /**
     * The name of the Babel plugin the service will insert into the targets configurations if
     * the target `hot` property is `true`
     * @type {string}
     */
    this.hotPluginName = &apos;react-hot-loader/babel&apos;;
    /**
     * The name of the entry the service will insert into the target if the target `hot` property
     * is `true`.
     * @type {string}
     */
    this.hotEntry = &apos;react-hot-loader/patch&apos;;
    /**
     * The name of the loader with the Babel configurations.
     * @type {string}
     */
    this.babelLoaderName = &apos;babel-loader&apos;;
  }
  /**
   * This is the method called when the plugin is loaded by projext. It just gets the events service
   * and registers the listeners for the reducer events that handle the JS rules, fonts rules,
   * images rules and target configuration.
   * @param {Projext} app The projext main container.
   */
  register(app) {
    const events = app.get(&apos;events&apos;);
    // Add the listener for the JS files rules event.
    events.on(this.jsRulesEvent, (rules, params) =&gt; (
      this.updateJSRules(rules, params.target, app.get(&apos;targets&apos;))
    ));
    // Add the listener for the SCSS files rules event.
    events.on(this.scssRulesEvent, (rules, params) =&gt; (
      this.updateStylesRules(rules, params.target, app.get(&apos;targets&apos;))
    ));
    // Add the listener for the CSS files rules event.
    events.on(this.cssRulesEvent, (rules, params) =&gt; (
      this.updateStylesRules(rules, params.target, app.get(&apos;targets&apos;))
    ));
    // Add the listener for the font files rules event.
    events.on(this.fontsRulesEvent, (rules, params) =&gt; (
      this.updateFontsRules(rules, params.target, app.get(&apos;targets&apos;))
    ));
    // Add the listener for the font files rules event.
    events.on(this.imagesRulesEvent, (rules, params) =&gt; (
      this.updateImagesRules(rules, params.target, app.get(&apos;targets&apos;))
    ));
    // Add the listener for the target configuration event.
    events.on(
      this.targetEventName,
      (config, params) =&gt; this.updateTargetConfiguration(config, params.target)
    );
  }
  /**
   * This method gets called when projext reduces the JS rules of a target. It validates the target
   * settings and makes the necessary modifications to the Babel loader configuration.
   * @param {Array}   currentRules The list of JS rules for the webpack configuration.
   * @param {Target}  target       The target information.
   * @param {Targets} targets      The targets service, to get the information of targets the
   *                               one being processed may need for SSR.
   * @return {Array} The updated list of rules.
   */
  updateJSRules(currentRules, target, targets) {
    let updatedRules;
    // If the target `framework` setting is the right one...
    if (target.framework === this.frameworkProperty) {
      // ...copy the list of rules.
      updatedRules = currentRules.slice();
      // Get the first rule of the list (there&apos;s usually only one).
      const [baseJSRule] = updatedRules;
      // Get the index of the Babel loader.
      const babelLoaderIndex = this._findBabelLoaderIndex(baseJSRule.use);
      // If the Babel loader is preset...
      if (babelLoaderIndex &gt; -1) {
        // ...get the framework options for the target.
        const options = this._getTargetOptions(target);
        // Push the paths for SSR targets
        baseJSRule.include.push(...options.ssr.map((name) =&gt; {
          const targetInfo = targets.getTarget(name);
          return new RegExp(targetInfo.folders.source);
        }));

        // ...replace it with an updated version.
        baseJSRule.use[babelLoaderIndex] = this._updateBabelLoader(
          baseJSRule.use[babelLoaderIndex],
          target.hot
        );
      }
    } else {
      // ...otherwise, just set to return the received rules.
      updatedRules = currentRules;
    }

    // Return the updated rules
    return currentRules;
  }
  /**
   * This method gets called when projext reduces the stylesheet (for both SCSS and CSS) rules of a
   * target. It validates the target settings, and if the target implements SSR, it adds the
   * `include` setting on the rule for the SSR targets directories.
   * @param {Array}   currentRules The list of fonts rules for the webpack configuration.
   * @param {Target}  target       The target information.
   * @param {Targets} targets      The targets service, to get the SSR targets information.
   * @return {Array} The updated list of rules.
   */
  updateStylesRules(currentRules, target, targets) {
    let updatedRules;
    // If the target `framework` setting is the right one...
    if (target.framework === this.frameworkProperty) {
      // ...copy the list of rules.
      updatedRules = currentRules.slice();
      // Get the first rule of the list (there&apos;s usually only one).
      const [mainRule] = updatedRules;
      // Get the target framework options.
      const options = this._getTargetOptions(target);
      // If the `include` option is a list, keep it like that, otherwise, convert it into a list.
      const include = Array.isArray(mainRule.include) ?
        mainRule.include :
        [mainRule.include];

      // Loop all the possible SSR targets and add their paths to the `include` option.
      include.push(...options.ssr.map((name) =&gt; (
        new RegExp(targets.getTarget(name).folders.source)
      )));

      // Overwrite the rule `include` option.
      mainRule.include = include;
    } else {
      // ...otherwise, just set to return the received rules.
      updatedRules = currentRules;
    }

    // Return the updated rules.
    return updatedRules;
  }
  /**
   * This method gets called when projext reduces the fonts files rules of a target. It validates
   * the target settings, and if the target implements SSR, it adds the `include` setting on
   * the SVG rule for the SSR targets directories.
   * @param {Array}   currentRules The list of fonts rules for the webpack configuration.
   * @param {Target}  target       The target information.
   * @param {Targets} targets      The targets service, to get the SSR targets information.
   * @return {Array} The updated list of rules.
   */
  updateFontsRules(currentRules, target, targets) {
    let updatedRules;
    // If the target `framework` setting is the right one...
    if (target.framework === this.frameworkProperty) {
      // ...copy the list of rules.
      updatedRules = currentRules.slice();
      // Find the loader used for SVG files.
      const svgLoader = updatedRules.find((rule) =&gt; &apos;.svg&apos;.match(rule.test));
      // If the loader was found...
      if (svgLoader) {
        // ...get the target framework options.
        const options = this._getTargetOptions(target);
        // If the `include` option is a list, keep it like that, otherwise, convert it into a list.
        const include = Array.isArray(svgLoader.include) ?
          svgLoader.include :
          [svgLoader.include];

        // Loop all the possible SSR targets and add their _&quot;fonts path&quot;_ to the `include` option.
        include.push(...options.ssr.map((name) =&gt; (
          this._getTargetFontsRegExp(targets.getTarget(name))
        )));

        // Overwrite the SVG loder `include` option.
        svgLoader.include = include;
      }
    } else {
      // ...otherwise, just set to return the received rules.
      updatedRules = currentRules;
    }

    // Return the updated rules.
    return updatedRules;
  }
  /**
   * This method gets called when projext reduces the images files rules of a target. It validates
   * the target settings, and if the target implements SSR, it adds the `exclude` setting on
   * the SVG rule for the SSR targets fonts directories.
   * @param {Array}   currentRules The list of fonts rules for the webpack configuration.
   * @param {Target}  target       The target information.
   * @param {Targets} targets      The targets service, to get the SSR targets information.
   * @return {Array} The updated list of rules.
   */
  updateImagesRules(currentRules, target, targets) {
    let updatedRules;
    // If the target `framework` setting is the right one...
    if (target.framework === this.frameworkProperty) {
      // ...copy the list of rules.
      updatedRules = currentRules.slice();
      // Find the loader used for SVG files.
      const svgLoader = updatedRules.find((rule) =&gt; &apos;.svg&apos;.match(rule.test));
      // If the loader was found...
      if (svgLoader) {
        // ...get the target framework options.
        const options = this._getTargetOptions(target);
        // If the `exclude` option is a list, keep it like that, otherwise, convert it into a list.
        const exclude = Array.isArray(svgLoader.exclude) ?
          svgLoader.exclude :
          [svgLoader.exclude];

        // Loop all the possible SSR targets and add their _&quot;fonts path&quot;_ to the `exclude` option.
        exclude.push(...options.ssr.map((name) =&gt; (
          this._getTargetFontsRegExp(targets.getTarget(name))
        )));

        // Overwrite the SVG loder `exclude` option.
        svgLoader.exclude = exclude;
      }
    } else {
      // ...otherwise, just set to return the received rules.
      updatedRules = currentRules;
    }

    // Return the updated rules.
    return updatedRules;
  }
  /**
   * This method gets called when projext reduces a target configuration for Wepack. It validates
   * the target settings and if HMR is enabled, it updates the `entry` setting with the required
   * changes for the React Hot Loader.
   * @param {Object} currentConfiguration The current configuration for the target.
   * @param {Target} target               The target information.
   * @return {Object} The updated configuration.
   */
  updateTargetConfiguration(currentConfiguration, target) {
    let updatedConfiguration;
    // If the target `framework` and `hot` have the required values...
    if (target.framework === this.frameworkProperty &amp;&amp; target.hot) {
      // Copy the configuration.
      updatedConfiguration = Object.assign({}, currentConfiguration);
      // Update the `publicPath`, required by the loader.
      updatedConfiguration.output.publicPath = &apos;/&apos;;
      // Get target entry name.
      const [entryName] = Object.keys(updatedConfiguration.entry);
      // Get the list of entries for the target.
      const entries = updatedConfiguration.entry[entryName];
      // Check if the `babel-polyfill` is present, since it always needs to be first.
      const polyfillIndex = entries.indexOf(&apos;babel-polyfill&apos;);
      // If the `babel-polyfill` is present...
      if (polyfillIndex &gt; -1) {
        // ...push the required entry after it.
        entries.splice(polyfillIndex + 1, 0, this.hotEntry);
      } else {
        // ...push the required entry as the first item.
        entries.unshift(this.hotEntry);
      }
    } else {
      // ...otherwise, just set to return the received configuration.
      updatedConfiguration = currentConfiguration;
    }

    return updatedConfiguration;
  }
  /**
   * Merge the default framework options with the overwrites the target may have, and return the
   * dictionary with the _&quot;final options&quot;_, ready to use.
   * @param {Target} target The target information.
   * @return {Object}
   * @ignore
   * @access protected
   */
  _getTargetOptions(target) {
    return Object.assign(
      {},
      this.frameworkOptions,
      target.frameworkOptions || {}
    );
  }
  /**
   * Gets the RegExp for a fonts folder inside a given target source directory. This is used on
   * the fonts SVG loader to `include` the files and on the images SVG loader to `exclude` them,
   * that way SVG files inside a folder that matches the RegExp get handled as fonts and if they
   * don&apos;t match it, they get handled as images.
   * @param {Target} target The target information.
   * @return {RegExp}
   * @ignore
   * @access protected
   */
  _getTargetFontsRegExp(target) {
    return new RegExp(`${target.paths.source}/(?:.*?/)?fonts/.*?`, &apos;i&apos;);
  }
  /**
   * Finds the index of the Babel loader on a list of loaders.
   * @param {Array} loaders The list of loaders.
   * @return {number}
   * @ignore
   * @access protected
   */
  _findBabelLoaderIndex(loaders) {
    return loaders.findIndex((loader) =&gt; {
      const isString = typeof loader === &apos;string&apos;;
      return (isString &amp;&amp; loader === this.babelLoaderName) ||
        (!isString &amp;&amp; loader.loader === this.babelLoaderName);
    });
  }
  /**
   * Updates an existing Babel loader configuration with the required presets and plugins to work
   * with React code.
   * The method will only modify the loader if is not on a string format and has an `options`
   * object.
   * @param {Object|string} babelLoader The loader to update.
   * @param {boolean}       hot         Whether or not the target will run with HMR. This will
   *                                    make the method disable the `modules` feature as is a
   *                                    requirement of the React Hot Loader for it to be `false`.
   * @return {Object|string}
   * @ignore
   * @access protected
   */
  _updateBabelLoader(babelLoader, hot) {
    let updatedLoader;
    /**
     * If the loader is a `string` or it doesn&apos;t have an `options` property, then the project uses
     * an external `.babelrc`, so it won&apos;t be updated.
     */
    if (typeof babelLoader !== &apos;string&apos; &amp;&amp; babelLoader.options) {
      // Copy the loader reference.
      updatedLoader = Object.assign({}, babelLoader);
      // Access the loader options.
      const { options } = updatedLoader;
      // If it doesn&apos;t have a presets list, create it.
      if (!options.presets) {
        options.presets = [];
      }
      // Push the required preset.
      options.presets.push([this.presetName]);
      // If the target will run with HMR...
      if (hot) {
        // If it doesn&apos;t have a plugins list, create it.
        if (!options.plugins) {
          options.plugins = [];
        }
        // Push the required plugin.
        options.plugins.push([this.hotPluginName]);
        // Get the index of the `env` preset, in order to disable `modules`.
        const envPresetIndex = options.presets.findIndex((preset) =&gt; {
          const [presetName] = preset;
          return presetName === &apos;env&apos;;
        });
        // If the `env` preset is present...
        if (envPresetIndex &gt; -1) {
          // Get the `env` preset options.
          const [, envPresetOptions] = options.presets[envPresetIndex];
          // Disable `modules`.
          envPresetOptions.modules = false;
        }
      }
    } else {
      updatedLoader = babelLoader;
    }

    return updatedLoader;
  }
}

module.exports = ProjextReactPlugin;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
